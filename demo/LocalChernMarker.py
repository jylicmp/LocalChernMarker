# -*- coding: utf-8 -*-
"""
Created on Thu Sep 30 11:20:09 2021
More efficient calculation of local Chern marker in matrix algorithm of 0,1,2 dimansion system
Routine is based on the extention package of PythTB pcn.py (https://github.com/nicodemosvarnava/pcn) and the following articles.
1.T. Rauch, T. Olsen, D. Vanderbilt, and I. Souza, Phys. Rev. B 98, 115108 (2018)
2.N. Varnava and D. Vanderbilt, Phys. Rev. B 98, 245117 (2018)

@author: Jiayu Li@SUSTech
"""

from pythtb import * # import TB model class
import numpy as np

# Calculation of the orbital-resolved Chern number C(l) for each orbital l
# of a spinor slab model (extended in two direction and finite in the third)
# The routine assumes dim_k=2 while dim_r=2(one layer) or 3(many layers) and C(l) corresponds to
# The component of the partial Chern vector along the k_1 x k_2 direction, i.e., Cxy(l)
#
# Input:
#  1. my_model: a spinful slab model generated by PythTb, with translational symmetry in first two direction
#  2. n_occ: number of occupied bands

def lcm_2d(my_model, n_occ):
    n_spin = my_model._nspin
    n_orb = my_model._norb
    dim_k = my_model._dim_k
    n_bands = n_spin * n_orb
    n_unocc = n_bands - n_occ
    
    orbs = my_model._orb
    hops = my_model._hoppings
    n_hop = len(hops)
    kper = my_model._per

    
    # generate uniform k-mesh
    kmesh = 101
    kpts_uni = []
    n_k = kmesh * kmesh
    sym_kmesh = int(kmesh/2)
    for i in range(kmesh):
        for j in range(kmesh):
            k_vec = [(-sym_kmesh + float(i)) / float(kmesh),(-sym_kmesh + float(j)) / float(kmesh)]
            kpts_uni.append(k_vec)
            
    # solve system on a uniform 2d k-grid
    print("     Calculating energy eigenvalues E_nk and eigenvectors \psi_nk..")
    evals, evecs = my_model.solve_all(kpts_uni, eig_vectors=True )
    # reshape eignvectors
    evec = np.zeros((n_bands, n_k, n_bands), dtype='complex')
    for n in range(n_bands):
        for k in range(n_k):
            evec[n,k] = [item for sublist in evecs[n,k] for item in sublist]
    
    # wavefunction matrices of occupied and unoccupied states
    vmat = evec[:n_occ, :, :]
    cmat = evec[n_occ:, :, :]
    
    # hopping matrix
    print("     Calculating hopping matrix..")
    dmat = np.zeros((dim_k, n_k, n_bands, n_bands), dtype="complex")
    for ik in range(n_k):
        for ir in range(dim_k):
            for ihop in range(n_hop):
                r1 = hops[ihop][1]
                r2 = hops[ihop][2]
                r12 = hops[ihop][3][kper] + orbs[r2][kper] - orbs[r1][kper]
                dmat[ir, ik, 2*r1:2*r1+2:1, 2*r2:2*r2+2:1] += hops[ihop][0] * (-r12[ir]) * np.exp(2.j*np.pi* np.dot(r12, kpts_uni[ik]))
                dmat[ir, ik, 2*r2:2*r2+2:1, 2*r1:2*r1+2:1] += hops[ihop][0].T.conj() * (r12[ir]) * np.exp(-2.j*np.pi* np.dot(r12, kpts_uni[ik]))
    
    # position matrix
    print("     Calculating position matrices X_vc(k) and Y_vc(k)..")
    posvc = np.zeros((dim_k, n_k, n_occ, n_unocc), dtype="complex")
    for ik in range(n_k):
        for ir in range(dim_k):
            posvc[ir, ik] = (vmat[:,ik,:].conj()) @ dmat[ir, ik] @ (cmat[:,ik,:].T)
            for v in range(n_occ):
                for c in range(n_unocc):
                    posvc[ir, ik, v, c] = posvc[ir, ik, v, c] / (evals[c+n_occ,ik] - evals[v,ik])
    
    # local Chern number
    print("     Calculating partial Chern number C(l)..")
    cxy = np.zeros(n_bands, dtype="float")
    for ik in range(n_k):
        cxy += -4 * np.pi * np.diag( (vmat[:,ik,:].T) @ (posvc[0, ik]) @ (posvc[1,ik].T.conj()) @ (vmat[:,ik,:].conj()) ).imag / float(n_k)
    
    return cxy



#=====================================================================================================================
                
# Calculation of the orbital-resolved Chern number C(l) for each orbital l
# of a spinor stick model (finite in the two directions and extended in third)
# The routine assumes dim_k = 1 while dim_r = 3 and C(l) corresponds to
# The component of the partial Chern number normal to the x-z surface, i.e., Cxz(l)
# Notice that this partial Chern number extremely relies on the surface geometry of the stick model
#
# Input:
#  1. my_model: a spinful stick model generated by PythTb, with translational symmetry in third direction
#  2. n_occ: number of occupied bands

def lcm_1d(my_model, n_occ):
    n_spin = my_model._nspin
    n_orb = my_model._norb
    dim_k = my_model._dim_k
    n_bands = n_spin * n_orb
    n_unocc = n_bands - n_occ
    
    orbs = my_model._orb
    hops = my_model._hoppings
    n_hop = len(hops)
    kper = my_model._per
    
    # generate uniform k-mesh
    kmesh = 101
    kpts_uni = []
    n_k = kmesh
    sym_kmesh = int(kmesh / 2)
    for i in range(kmesh):
        kpts_uni.append((-sym_kmesh + float(i)) / float(kmesh))
    
    # solve system on a uniform 1d k-mesh
    print("     Calculating energy eigenvalues E_nk and eigenvectors \psi_nk..")
    evals, evecs = my_model.solve_all(kpts_uni, eig_vectors=True )
    # reshape eignvectors
    evec = np.zeros((n_bands, n_k, n_bands), dtype='complex')
    for n in range(n_bands):
        for k in range(n_k):
            evec[n,k] = [item for sublist in evecs[n,k] for item in sublist]
    
    # wavefunction matrices of occupied and unoccupied states
    vmat = evec[:n_occ, :, :]
    cmat = evec[n_occ:, :, :]
    
    # hopping matrix
    print("     Calculating hopping matrix..")
    dmat = np.zeros((2, n_k, n_bands, n_bands), dtype="complex")
    for ik in range(n_k):
        for ir in [0, 2]:
            for ihop in range(n_hop):
                r1 = hops[ihop][1]
                r2 = hops[ihop][2]
                r12 = hops[ihop][3] + orbs[r2] - orbs[r1]
                dmat[int(ir/2), ik, 2*r1:2*r1+2:1, 2*r2:2*r2+2:1] += hops[ihop][0] * (-r12[ir]) * np.exp(2.j*np.pi* np.dot(r12[kper], kpts_uni[ik]))
                dmat[int(ir/2), ik, 2*r2:2*r2+2:1, 2*r1:2*r1+2:1] += hops[ihop][0].T.conj() * (r12[ir]) * np.exp(-2.j*np.pi* np.dot(r12[kper], kpts_uni[ik]))
    
    # position matrix
    print("     Calculating position matrices X_vc(k) and Z_vc(k)..")
    posvc = np.zeros((2, n_k, n_occ, n_unocc), dtype="complex")
    for ik in range(n_k):
        for ir in range(2):
            posvc[ir, ik] = (vmat[:,ik,:].conj()) @ dmat[ir, ik] @ (cmat[:,ik,:].T)
            for v in range(n_occ):
                for c in range(n_unocc):
                    posvc[ir, ik, v, c] = posvc[ir, ik, v, c] / (evals[c+n_occ,ik] - evals[v,ik])
    
    # local Chern number
    print("     Calculating partial Chern number C(l)..")
    cxz = np.zeros(n_bands, dtype="float")
    for ik in range(n_k):
        cxz += -4 * np.pi * np.diag( (vmat[:,ik,:].T) @ (posvc[0, ik]) @ (posvc[1,ik].T.conj()) @ (vmat[:,ik,:].conj()) ).imag / float(n_k)
    
    return cxz
    

#=====================================================================================================================
                
# Calculation of the orbital-resolved Chern number C(l) for each orbital l
# of a spinor dot model (finite in all three directions)
# The component of the partial Chern number cij can be chosen in any direction, depending on the inputs
#
# Input:
#  1. my_model: a spinful model generated by PythTb, with open boundary condition in any direction
#  2. n_occ: number of occupied bands
#  3. ii, jj: the subscripts of the component of the partial Chern marker cij, with (0,1,2) denote (x,y,z), respectively

def lcm_0d(my_model, n_occ, ii, jj):
    n_spin = my_model._nspin
    n_orb = my_model._norb
    n_bands = n_spin * n_orb
    n_unocc = n_bands - n_occ
    
    orbs = my_model._orb
    hops = my_model._hoppings
    n_hop = len(hops)
    
    # solve system 
    print("     Calculating energy eigenvalues E_n and eigenvectors \psi_n..")
    evals, evecs = my_model.solve_all(eig_vectors=True)
    # reshape eignvectors
    evec = np.zeros((n_bands, n_bands), dtype='complex')
    for n in range(n_bands):
        evec[n] = [item for sublist in evecs[n] for item in sublist]
        
    # wavefunction matrices of occupied and unoccupied states
    vmat = evec[:n_occ]
    cmat = evec[n_occ:]
    
    # hopping matrix
    print("     Calculating hopping matrix..")
    dmat = np.zeros((2, n_bands, n_bands), dtype="complex")
    
    for ihop in range(n_hop):
        r1 = hops[ihop][1]
        r2 = hops[ihop][2]
        r12 = orbs[r2] - orbs[r1]
        dmat[0, 2*r1:2*r1+2:1, 2*r2:2*r2+2:1] += hops[ihop][0] * (-r12[ii])
        dmat[1, 2*r1:2*r1+2:1, 2*r2:2*r2+2:1] += hops[ihop][0] * (-r12[jj])
        dmat[0, 2*r2:2*r2+2:1, 2*r1:2*r1+2:1] += hops[ihop][0].T.conj() * (r12[ii])
        dmat[1, 2*r2:2*r2+2:1, 2*r1:2*r1+2:1] += hops[ihop][0].T.conj() * (r12[jj])
    
    # position matrix
    print("     Calculating position matrices R_i_vc and R_j_vc..")
    posvc = np.zeros((2, n_occ, n_unocc), dtype="complex")
    for ir in range(2):
        posvc[ir] = (vmat.conj()) @ (dmat[ir]) @ (cmat.T)
        for v in range(n_occ):
            for c in range(n_unocc):
                posvc[ir, v, c] = posvc[ir, v, c] / (evals[c+n_occ] - evals[v])
                
    # local Chern number
    print("     Calculating partial Chern number C(l)..")
    cij = -4 * np.pi * np.diag( (vmat.T) @ (posvc[0]) @ (posvc[1].T.conj()) @ (vmat.conj()) ).imag
    
    return cij